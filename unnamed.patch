Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/vcs.xml	(revision )
+++ .idea/vcs.xml	(revision )
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/modules.xml	(revision )
+++ .idea/modules.xml	(revision )
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/Rlist.iml" filepath="$PROJECT_DIR$/Rlist.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision )
+++ .idea/misc.xml	(revision )
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ClientPropertiesManager">
+    <properties class="javax.swing.AbstractButton">
+      <property name="hideActionText" class="java.lang.Boolean" />
+    </properties>
+    <properties class="javax.swing.JComponent">
+      <property name="html.disable" class="java.lang.Boolean" />
+    </properties>
+    <properties class="javax.swing.JEditorPane">
+      <property name="JEditorPane.w3cLengthUnits" class="java.lang.Boolean" />
+      <property name="JEditorPane.honorDisplayProperties" class="java.lang.Boolean" />
+      <property name="charset" class="java.lang.String" />
+    </properties>
+    <properties class="javax.swing.JList">
+      <property name="List.isFileList" class="java.lang.Boolean" />
+    </properties>
+    <properties class="javax.swing.JPasswordField">
+      <property name="JPasswordField.cutCopyAllowed" class="java.lang.Boolean" />
+    </properties>
+    <properties class="javax.swing.JSlider">
+      <property name="Slider.paintThumbArrowShape" class="java.lang.Boolean" />
+      <property name="JSlider.isFilled" class="java.lang.Boolean" />
+    </properties>
+    <properties class="javax.swing.JTable">
+      <property name="Table.isFileList" class="java.lang.Boolean" />
+      <property name="JTable.autoStartsEdit" class="java.lang.Boolean" />
+      <property name="terminateEditOnFocusLost" class="java.lang.Boolean" />
+    </properties>
+    <properties class="javax.swing.JToolBar">
+      <property name="JToolBar.isRollover" class="java.lang.Boolean" />
+    </properties>
+    <properties class="javax.swing.JTree">
+      <property name="JTree.lineStyle" class="java.lang.String" />
+    </properties>
+    <properties class="javax.swing.text.JTextComponent">
+      <property name="caretAspectRatio" class="java.lang.Double" />
+      <property name="caretWidth" class="java.lang.Integer" />
+    </properties>
+  </component>
+  <component name="MavenProjectsManager">
+    <option name="originalFiles">
+      <list>
+        <option value="$PROJECT_DIR$/pom.xml" />
+      </list>
+    </option>
+  </component>
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/out" />
+  </component>
+</project>
\ No newline at end of file
Index: Rlist.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Rlist.iml	(revision )
+++ Rlist.iml	(revision )
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule="true" type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" LANGUAGE_LEVEL="JDK_1_5" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/target/classes" />
+    <output-test url="file://$MODULE_DIR$/target/test-classes" />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/target" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- pom.xml	(revision )
+++ pom.xml	(revision )
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>RList</groupId>
+    <artifactId>Rlist</artifactId>
+    <version>1.0-SNAPSHOT</version>
+
+
+</project>
\ No newline at end of file
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/compiler.xml	(revision )
+++ .idea/compiler.xml	(revision )
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <annotationProcessing>
+      <profile name="Maven default annotation processors profile" enabled="true">
+        <sourceOutputDir name="target/generated-sources/annotations" />
+        <sourceTestOutputDir name="target/generated-test-sources/test-annotations" />
+        <outputRelativeToContentRoot value="true" />
+        <module name="Rlist" />
+      </profile>
+    </annotationProcessing>
+    <bytecodeTargetLevel>
+      <module name="Rlist" target="1.5" />
+    </bytecodeTargetLevel>
+  </component>
+</project>
\ No newline at end of file
Index: src/main/java/RList.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/RList.java	(revision )
+++ src/main/java/RList.java	(revision )
@@ -0,0 +1,296 @@
+
+import java.util.*;
+
+/**
+ * Created by LuMoR on 06.02.2017.
+ */
+public class RList<E> implements List<E> {
+
+    private int size = 0;
+    private Node<E> first;
+    private Node<E> last;
+
+    public int size() {
+        return size;
+    }
+
+    private void linkFirst(E el){
+        final Node el_first = first;
+        final Node newNode = new Node(null, el, el_first);
+        first = newNode;
+        if (el_first == null)
+            last = newNode;
+        else
+            el_first.prev =newNode;
+
+        size++;
+
+    }
+
+    private void linkLast(E el){
+        final Node el_last = last;
+        final Node newNode = new Node(el_last, el, null);
+        last = newNode;
+        if (el_last == null)
+            first = newNode;
+        else
+            el_last.next = newNode;
+        size++;
+
+    }
+
+    private void linkBefore(E el, Node<E> succ) {
+        // assert succ != null;
+        final Node<E> pred = succ.prev;
+        final Node<E> newNode = new Node(pred, el, succ);
+        succ.prev = newNode;
+        if (pred == null)
+            first = newNode;
+        else
+            pred.next = newNode;
+        size++;
+    }
+
+    private Node<E> node(int index) {
+        // assert isElementIndex(index);
+
+        if (index < (size >> 1)) {
+            Node<E> x = first;
+            for (int i = 0; i < index; i++)
+                x = x.next;
+            return x;
+        } else {
+            Node<E> x = last;
+            for (int i = size - 1; i > index; i--)
+                x = x.prev;
+            return x;
+        }
+    }
+
+    public boolean isEmpty() {
+        if (size == 0)
+            return true;
+        else
+            return false;
+    }
+
+    public boolean contains(Object o) {
+        if (indexOf(o) != -1)
+            return true;
+        else
+            return false;
+    }
+
+
+    public boolean add(E el) {
+        linkLast(el);
+        return true;
+    }
+
+    public void add(int index, E el) {
+
+        if (index >= 0 && index <= size) {
+            if (index == size)
+                linkLast(el);
+            else
+                linkBefore(el, node(index));
+        }
+
+    }
+
+    public boolean addAll(Collection c) {
+        return false;
+    }
+
+    public boolean addAll(int index, Collection c) {
+        return false;
+    }
+
+    public E get(int index) {
+        if (index >= 0 && index <= size) {
+            return node(index).item;
+        }
+        else
+            return null;
+    }
+
+    public E set(int index, E newValue) {
+        /* Проверить индекс вхождения */
+            Node<E> el = node(index);
+            E oldValue = el.item;
+            el.item = newValue;
+            return oldValue;
+    }
+
+    private E unlinkFirst(Node<E> f) {
+
+        final E itemvalue = f.item;
+        final Node<E> next = f.next;
+        f.item = null;
+        f.next = null;
+        first = next;
+        if (next == null)
+            last = null;
+        else
+            next.prev = null;
+        size--;
+        return itemvalue;
+    }
+
+    private E unlinkLast(Node<E> f) {
+
+        final E itemvalue = f.item;
+        final Node<E> prev = f.prev;
+        f.item = null;
+        f.prev = null;
+        last = prev;
+        if (prev == null)
+            first = null;
+        else
+            prev.next = null;
+        size--;
+        return itemvalue;
+    }
+
+    private E unlinkAny(Node<E> f) {
+
+        final E itemvalue = f.item;
+        final Node<E> next = f.next;
+        final Node<E> prev = f.prev;
+
+        if ( prev == null){
+            first = next;
+        }
+        else {
+            prev.next = next;
+            f.prev = null;
+        }
+        if ( next == null){
+            last = prev;
+        }
+        else {
+            next.prev = prev;
+            f.next = null;
+        }
+
+        f.item = null;
+        size--;
+        return itemvalue;
+    }
+
+    public boolean remove(Object o) {
+        int io = indexOf(o);
+        if (io != -1) {
+           unlinkAny(node(io));
+           return true;
+        }
+        else return false;
+    }
+
+    public E remove(int index) {
+        if (index >= 0 && index <= size) {
+            return unlinkAny(node(index));
+        }
+        else
+            return null;
+    }
+
+    public boolean removeAll(Collection c) {
+
+        return false;
+    }
+
+    public void clear() {
+
+        for (Node<E> x = first; x != null; ) {
+            Node<E> next = x.next;
+            x.item = null;
+            x.next = null;
+            x.prev = null;
+            x = next;
+        }
+        first = last = null;
+        size = 0;
+    }
+
+
+    public Object[] toArray() {
+        return new Object[0];
+    }
+
+    public int indexOf(Object o) {
+        int index = 0;
+        if (o == null) {
+            for (Node<E> el = first; el != null; el = el.next) {
+                if (el.item == null)
+                    return index;
+                index++;
+            }
+        } else {
+            for (Node<E> el = first; el != null; el = el.next) {
+                if (o.equals(el.item))
+                    return index;
+                index++;
+            }
+        }
+        return -1;
+    }
+
+    public int lastIndexOf(Object o) {
+        int index = size;
+        if (o == null) {
+            for (Node<E> el = last; el != null; el = el.prev) {
+                index--;
+                if (el.item == null)
+                    return index;
+            }
+        } else {
+            for (Node<E> el = last; el != null; el = el.prev) {
+                index--;
+                if (o.equals(el.item))
+                    return index;
+            }
+        }
+        return -1;
+    }
+
+    public Iterator iterator() {
+        return null;
+    }
+
+    public ListIterator listIterator() {
+        return null;
+    }
+
+    public ListIterator listIterator(int index) {
+        return null;
+    }
+
+    public List subList(int fromIndex, int toIndex) {
+        return null;
+    }
+
+    public boolean retainAll(Collection c) {
+        return false;
+    }
+
+    public boolean containsAll(Collection c) {
+        return false;
+    }
+
+    public Object[] toArray(Object[] a) {
+        return new Object[0];
+    }
+
+    private static class Node<E> {
+        E item;
+        Node<E> next;
+        Node<E> prev;
+
+        Node(Node<E> prev, E element, Node<E> next) {
+            this.item = element;
+            this.next = next;
+            this.prev = prev;
+        }
+    }
+}
Index: src/main/java/Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/Test.java	(revision )
+++ src/main/java/Test.java	(revision )
@@ -0,0 +1,25 @@
+/**
+ * Created by LuMoR on 07.02.2017.
+ */
+
+
+public class Test {
+    public static void main(String[] args){
+        RList<String> TRList = new RList<String>();
+
+        TRList.add("First");
+        TRList.add("Second");
+        int ii = TRList.indexOf("Second");
+        TRList.add(TRList.size(), "3333");
+        //System.out.println(ii);
+        //System.out.println(TRList.contains("First"));
+        System.out.println(TRList.isEmpty());
+        for (int i=0;i<TRList.size();i++){
+        System.out.println(" - "+i+" . "+TRList.get(i));}
+        TRList.remove("3333");
+        System.out.println(TRList.isEmpty());
+        for (int i=0;i<TRList.size();i++){
+            System.out.println(" - "+i+" . "+TRList.get(i));}
+        System.out.println("OK");
+    }
+}
